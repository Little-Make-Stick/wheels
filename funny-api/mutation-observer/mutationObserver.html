<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .border-black{
            border: 1px solid #000;
        }
    </style>
    <style>
        ol{
            border: 2px solid #ccc;
            background: cornsilk;
            padding: 20px 40px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <header>
        <h2>cjihgevn kerbnekbnijbrn burkhnirhjntigbi</h2>
    </header>
    <div class="content">
        <p>MutationObserver接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。</p>
        <p>DOM 规范中的 MutationObserver() 构造函数——是 MutationObserver 接口内容的一部分——创建并返回一个新的观察器，它会在触发指定 DOM 事件时，调用指定的回调函数。</p>
        <p>MutationObserver 对 DOM 的观察不会立即启动；而必须先调用 observe() 方法来确定，要监听哪一部分的 DOM 以及要响应哪些更改。</p>
        <p>var observer = new MutationObserver(callback);</p>
        <ol>参数
            <li>callback</li>
            <p>一个回调函数，每当被指定的节点或子树以及配置项有Dom变动时会被调用。</p>
            <ol>回调函数拥有两个参数：
                <li>一个是描述所有被触发改动的 MutationRecord 对象数组，</li>
                <li>另一个是调用该函数的MutationObserver 对象。</li>
            </ol>
            <ol>返回值：
                <li>一个新的、包含监听 DOM 变化回调函数的 MutationObserver 对象。</li>
            </ol>
        </ol>
        <ol>
            方法：
            <li>observe()</li>
            <p>配置MutationObserver在DOM更改匹配给定选项时，通过其回调函数开始接收通知。</p>
            <p>mutationObserver.observe(target[, options])</p>
            <ol>参数
                <li>target</li>
                <p>DOM树中的一个要观察变化的DOM Node (可能是一个Element) , 或者是被观察的子节点树的根节点。</p>
                <li>options</li>
                <p>一个可选的<a href="#MutationObserverInit">MutationObserverInit</a> 对象，此对象的配置项描述了DOM的哪些变化应该提供给当前观察者的callback。</p>
            </ol>
            <li>disconnect()</li>
            <p>阻止 MutationObserver 实例继续接收的通知，直到再次调用其observe()方法，该观察者对象包含的回调函数都不会再被调用。</p>
            <p>mutationObserver.disconnect()</p>
            <p></p>
            <li>takeRecords()</li>
            <p>从MutationObserver的通知队列中删除所有待处理的通知，并将它们返回到MutationRecord对象的新Array中。</p>
            <p>mutationRecords = mutationObserver.takeRecords()</p>
        </ol>
        <ul>
            <li>milk</li>
            <li>coffee</li>
            <li>water</li>
        </ul>
        <div>1234567890</div>
        <ol class="obverser-text">
            变更记录：
        </ol>
        <button class="class-event-btn">class Opt</button>
        <button class="style-event-btn">style Opt</button>
        <button class="remove-event-btn">remove Opt</button>
        <button class="append-event-btn">append Opt</button>

        <div class="MutationObserverInit">
            <ol><a id="MutationObserverInit">## MutationObserverInit</a>
                <li>attributeFilter
                    <p>要监视的特定属性名称的数组。如果未包含此属性，则对所有属性的更改都会触发变动通知。</p>
                </li>
                <li>attributeOldValue
                    <p>当监视节点的属性改动时，将此属性设为 true 将记录任何有改动的属性的上一个值。</p>
                </li>
                <li>attributes
                    <p>设为 true 以观察受监视元素的属性值变更。默认值为 false。</p>
                </li>
                <li>characterData
                    <p>设为 true 以监视指定目标节点或子节点树中节点所包含的字符数据的变化。无默认值。</p>
                </li>
                <li>characterDataOldValue
                    <p>设为 true 以在文本在受监视节点上发生更改时记录节点文本的先前值。</p>
                </li>
                <li>childList
                    <p>设为 true 以监视目标节点（如果 subtree 为 true，则包含子孙节点）添加或删除新的子节点。默认值为 false。</p>
                </li>
                <li>subtree
                    <p>设为 true 以将监视范围扩展至目标节点整个节点树中的所有节点。MutationObserverInit 的其他值也会作用于此子树下的所有节点，而不仅仅只作用于目标节点。默认值为 false。</p>
                </li>
            </ol>
        </div>
    </div>
    <script>
        document.querySelector('.class-event-btn').addEventListener('click',classEvent);
        document.querySelector('.style-event-btn').addEventListener('click',styleEvent);
        document.querySelector('.remove-event-btn').addEventListener('click',removeEvent);
        document.querySelector('.append-event-btn').addEventListener('click',appendEvent);

        function classEvent(){
            let classStr = document.querySelector('ul').getAttribute('class') || '';
            let setClass = ~classStr.indexOf('border-black') ? '' : 'border-black';
            document.querySelector('ul').setAttribute('class',setClass);
        }

        function styleEvent(){
            let styleObj = document.querySelector('ul').style || {};
            let setStyle = styleObj.color == '' || styleObj.color == 'black' ? 'transparent' : 'black';
            document.querySelector('ul').style.color = setStyle;
        }

        function removeEvent(){
            let ulDom = document.querySelector('ul');
            if(ulDom){
                ulDom.removeChild(ulDom.children[0]);
            }
        }

        function appendEvent(){
            let ulDom = document.querySelector('ul');
            if(ulDom){
                let newNode = document.createElement('li');
                newNode.innerHTML = 'Orange';
                ulDom.appendChild(newNode)
            }
        }
 
        var ulElement = document.querySelector('ul');
        var config = {
            attributes: true,
            characterData: true,
            childList: true,
            subtree: true
        };

        var observer = new MutationObserver((arr,obj)=>{
            // console.log(arr[0])
            // MutationRecord {type: 'attributes', target: ul.border-black, addedNodes: NodeList(0), removedNodes: NodeList(0), previousSibling: null, …}
            // addedNodes: NodeList []
            // attributeName: "class"
            // attributeNamespace: null
            // nextSibling: null
            // oldValue: null
            // previousSibling: null
            // removedNodes: NodeList []
            // target: ul.border-black
            // type: "attributes"
            // [[Prototype]]: MutationRecord
            let {type,attributeName,target,addedNodes,removedNodes} = arr[0];
            let log = `type:${type},attribute:${attributeName},target:${target},addedNodes:${addedNodes[0]?addedNodes[0].outerHTML:null},removedNodes:${removedNodes[0]?removedNodes[0].outerHTML:null},`
            let newNode = document.createElement('li');
            newNode.innerText = log;
            document.querySelector('.obverser-text').appendChild(newNode)
        });
        observer.observe(ulElement,config);
    </script>
</body>
</html>